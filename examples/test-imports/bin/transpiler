#!/usr/bin/env node
const browserify = require('browserify');
const babelify = require('babelify');
const browserifyInc = require('browserify-incremental')
const fse = require('fs-extra');
const path = require('path');

var b = browserify(Object.assign({}, browserifyInc.args, {
  // your custom opts
}))
browserifyInc(b, {cacheFile: './browserify-cache.json'})

const cacheFile = path.join(process.cwd(), 'bin', '.browserify-cache');

// delete a transpiled file
module.exports.delete = function(file) {
  return new Promise((resolve, reject) => {
    fse.stat(file.abs, (err, stats) => {
      if (err)
        return reject(err);

      if (stats.isFile()) {
        fse.remove(file.abs, err => {
          if (err)
            reject(err);
          else
            resolve(file);
        });
      }
    });
  });
};

let bundler = null
/**
 * Transform a given file to it's browserified version, client only.
 */
module.exports.bundle = function(src, dist, browserifyOptions, babelOptions) {
  return new Promise((resolve, reject) => {
    if (bundler === null) {
      const options = Object.assign({}, browserifyInc.args, browserifyOptions);
      bundler = browserify(src.abs, options);
      browserifyInc(bundler, { cacheFile });
    }

    fse.ensureFileSync(dist.abs); // ensure file exists

    const writeStream = fse.createWriteStream(dist.abs);

    bundler
      .transform('babelify', babelOptions)
      .bundle()
      .on('error', err => {
        return reject(err);
      })
      .on('end', () => { /*do nothing*/ })
      .pipe(writeStream);

    writeStream.on('finish', () => resolve([src, dist]));
  });
}
